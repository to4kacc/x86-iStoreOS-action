name: ç”ŸæˆOTAå‡çº§æ–‡ä»¶

on:
  workflow_dispatch:  # æ‰‹åŠ¨è§¦å‘


jobs:
  generate:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: æ£€å‡ºä¸»åˆ†æ”¯
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: è·å–æœ€è¿‘5ä¸ªå›ºä»¶
        id: get_releases
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const crypto = require('crypto');
            const { promisify } = require('util');
            const stream = require('stream');
            const pipeline = promisify(stream.pipeline);

            try {
              // 1. è·å–æœ€è¿‘5ä¸ªå‘å¸ƒï¼ˆåˆ†é¡µå¤„ç†ï¼‰
              const releases = await github.paginate(
                github.rest.repos.listReleases,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  per_page: 5,  // åªè·å–æœ€æ–°5ä¸ª
                  request: { timeout: 15000 }
                }
              );

              if (releases.length === 0) {
                throw new Error('ä»“åº“ä¸­æ²¡æœ‰å‘å¸ƒç‰ˆæœ¬');
              }
            const asset = latest.data.assets.find(a => 
              a.name.toLowerCase().includes('istoreos') && 
              /combined.*efi\.img\.gz$/i.test(a.name)
            );

            if (!asset) {
              core.setFailed(`
                Target firmware not found. Expected a file like:
                iStoreOS-<version>-<arch>-squashfs-combined-efi.img.gz
                Available files: ${latest.data.assets.map(a => a.name).join(', ')}
              `);
            }
            const crypto = require('crypto');
            const response = await fetch(asset.browser_download_url);
            const buffer = await response.arrayBuffer();
            const sha256 = crypto.createHash('sha256').update(Buffer.from(buffer)).digest('hex');
            const workflowRun = await github.rest.actions.getWorkflowRun({
             owner: context.repo.owner,
             repo: context.repo.repo,
             run_id: process.env.GITHUB_RUN_ID,
            });
            const workflowStartTime = workflowRun.data.run_started_at;
            const buildDate = Math.floor(new Date(workflowStartTime).getTime() / 1000);
            
            // ğŸ”§ åœ¨è¿™é‡Œæ·»åŠ ä»£ç†å‰ç¼€
            const proxiedUrl = asset.browser_download_url;    
            
            const json = {
              "x86_64": [
                {
                  "build_date": String(buildDate),
                  "sha256sum": sha256,
                  "url": proxiedUrl  // ä½¿ç”¨å¸¦ä»£ç†çš„URL
                }
              ]
            };
            const fs = require('fs');
            fs.mkdirSync('tmp-api', { recursive: true });
            fs.writeFileSync('tmp-api/fw.json', JSON.stringify(json, null, 4));
            
      - name: æ£€å‡ºAPIåˆ†æ”¯
        run: |
          git fetch origin api:api
          git checkout api
          cp tmp-api/fw.json .
          git config user.name "actions-user"
          git config user.email "actions@github.com"
          git add fw.json
          git commit -m "Update fw.json @ $(date +'%Y-%m-%d %H:%M:%S')')" || echo "No changes to commit"
          git push origin api
